#!/bin/bash
# 
# Author: simargl <https://github.com/simargl>
# License: GPL v3

# Variables
ARCH="x86_64"
DBPATH="/var/lib/slackware"
CACHEDIR="/var/cache/slackware"
REPOSITORY=('https://mirror.netcologne.de/slackware/slackware64-current/patches'
            'https://mirror.netcologne.de/slackware/slackware64-current/slackware64'
            'https://github.com/simargl/slik-linux/releases/download/slackware-current')
   
# root check      
if [[ $EUID -ne 0 ]]; then echo "This script must be run as root" && exit 1; fi

# download file with wget ($1=filename; $2=target directory; $3=comment)
fn_download_file() {
    printf "\e[1;33m>>> \e[1;36mDownloading \e[1;32m%s\e[0m" "$3"  # Gentoo-like colors for the message
    wget -q -nv "$1" -P "$2" &
    pid=$!  # Get the PID of the wget process
    while kill -0 $pid >/dev/null 2>&1; do  # Loop until wget process is finished
        echo -n "."
        sleep 1  # Add a dot every second
    done
    wait $pid  # Wait for wget process to finish
    printf "\e[1;33m DONE\e[0m\n"  # Print "DONE" in yellow after download completion
}


fn_repo_update() {
    [ -f $DBPATH/packages.list ] && rm $DBPATH/packages.list
    echo -e "Synchronizing package databases..."
    for ((i=0; i<${#REPOSITORY[@]}; ++i)); do
        fn_download_file ${REPOSITORY[i]}/CHECKSUMS.md5 $DBPATH ${REPOSITORY[i]}
        cd $DBPATH || exit
        grep -E '\.tgz$|\.txz$' CHECKSUMS.md5 | cut -c 36- | sed "s|^|${REPOSITORY[i]}|g" | sort >> packages.list
        rm CHECKSUMS.md5
    done
    echo "Repositories: ""${#REPOSITORY[@]}""  Packages: ""$(grep -c ^ packages.list)"
}

fn_pkg_search() {
    if [[ $ARG && ${#ARG} -gt 0 ]]; then
        PKGSEARCH=$(grep $ARG $DBPATH/packages.list)
        if [[ "$PKGSEARCH" != "" ]]; then
            while read -r result; do
                nv=$(basename $result | sed 's/\(.*\)-[^-]*-[^-]*$/\1/')
                pkgnameR="$(echo $nv | sed 's/-[^-]*$//')"
                pkgverR="$(echo $nv | sed 's/.*-//')"
                I="Not installed"
                if [ -d $DBPATH/installed/$pkgnameR ]; then 
                    . $DBPATH/installed/$pkgnameR/pkginfo
                    if [ "$pkgverR" == "$pkgver" ]; then I="Installed"; else I="Outdated"; fi
                fi
                printf "\e[1;33m%-35s\e[0m\e[1;36m%-30s\e[0m\e[1;35m%s\e[0m\n" "$pkgnameR" "($pkgverR)" "$I"
            done <<< "$PKGSEARCH"
        fi
    fi
}

fn_get_pkgmatch() {
    grep /$1-[0-9] $DBPATH/packages.list | head -1
}

fn_check_pkgmatch_exists() {
    unset MISSING
    LIST="$@"
    for ONE in $LIST; do  
        PKGMATCH="$(fn_get_pkgmatch $ONE)"
        if [[ $PKGMATCH == "" ]]; then
            MISSING+=("$ONE"); 
        fi
    done
    if [[ ${#MISSING[@]} != 0 ]]; then
        for i in ${MISSING[*]}; do
            echo "E: Unable to locate package $i"
        done
        exit 1
    fi
}

fn_pkg_download() {
    if [ $ARG ]; then
        PKGMATCH=$(fn_get_pkgmatch $ARG)
        if [[ "$PKGMATCH" != "" ]]; then
            if [ ! -f $CACHEDIR/$(basename $PKGMATCH) ]; then
                fn_download_file $PKGMATCH $CACHEDIR "$(basename $PKGMATCH)"
            else
                echo "Using cached $(basename $PKGMATCH)"
            fi
            if [ ! -f $CACHEDIR/$(basename $PKGMATCH) ]; then    
                echo -e "$(basename $PKGMATCH) download failed"
                exit 1
            fi
        else
            echo "E: Unable to locate package $ARG"
        fi
    fi
}

fn_pkg_download_all() {
    fn_check_pkgmatch_exists $ARGD
    for ONE in $ARGD; do
        ARG="$ONE"
        fn_pkg_download
    done
}

fn_get_metadata() {
    nv=$(echo $1 | sed 's/\(.*\)-[^-]*-[^-]*$/\1/')
    pkgname="$(echo $nv | sed 's/-[^-]*$//')"
    pkgver="$(echo $nv | sed 's/.*-//')"
    pkgrel="$(echo ${1##*-} | sed 's/.t.z//')"
}

fn_write_metadata() {
    fn_get_metadata $1 $2
    mkdir -p $2/$DBPATH/installed/$pkgname
    echo pkgname="$pkgname" > $2/$DBPATH/installed/$pkgname/pkginfo
    echo pkgver="$pkgver" >> $2/$DBPATH/installed/$pkgname/pkginfo
    echo pkgrel="$pkgrel" >> $2/$DBPATH/installed/$pkgname/pkginfo
    # files
    tar -tvf $1 | awk '!/^d/ {print $NF}' | grep -v "install/" | sed 's/^/\//' > $2/$DBPATH/installed/$pkgname/files
}

fn_pkg_extract() {
    if [[ $ARG != "" && -f $ARG ]]; then
        echo "Extracting $ARG"
        tar -xf $ARG
    else
        exit 1
    fi
}

fn_pkg_extract_all() {
    for i in *.t?z; do
        [[ -e $i ]] || break
        ARG=$i
        echo "Installing $ARG --target-root=./install"
        [ ! -d install ] && mkdir install
        tar -xf $ARG -C install
        if [ -f "install/install/doinst.sh" ]; then cd install && sh ./install/doinst.sh 2>/dev/null; cd $OLDPWD || exit; fi
        fn_write_metadata $ARG install
        if [ -d install/install ]; then rm -r install/install; fi
    done
}

fn_pkg_install_local() {
    if [[ $ARG != "" && -f $ARG ]]; then
        echo "Installing $ARG"
        tar -xf $ARG -C /
        if [ -f "/install/doinst.sh" ]; then cd / && sh ./install/doinst.sh 2>/dev/null; cd $OLDPWD || exit; fi
        fn_write_metadata $ARG /
        if [ -d /install ]; then rm -r /install; fi
        fn_pkg_post_actions
    else
        exit 1
    fi
}

fn_pkg_post_actions() {
    ICONS=$(grep /usr/share/icons/hicolor         $DBPATH/installed/$pkgname/files)
    DESKTOP=$(grep /usr/share/applications        $DBPATH/installed/$pkgname/files)
    GSETTINGS=$(grep /usr/share/glib-2.0/schemas  $DBPATH/installed/$pkgname/files)
    FONTS=$(grep /usr/share/fonts/TTF             $DBPATH/installed/$pkgname/files)
    fn_pkg_post_actions_run
}

fn_pkg_post_actions_run() {
    if [ "$ICONS" ]; then gtk-update-icon-cache /usr/share/icons/hicolor; fi
    if [ "$DESKTOP" ]; then update-desktop-database; fi
    if [ "$GSETTINGS" ]; then glib-compile-schemas /usr/share/glib-2.0/schemas; fi
    if [ "$FONTS" ]; then fc-cache -f -s; mkfontscale /usr/share/fonts/TTF; mkfontdir /usr/share/fonts/TTF; fi
}

fn_pkg_install() {
    for ONE in $ARGI; do
        if [ -f $ONE ]; then
            ARG="$ONE"
            fn_pkg_install_local
            exit 0
        fi
    done
    fn_check_pkgmatch_exists $ARGI
    for ONE in $ARGI; do
        ARG="$ONE"
        if [ -d $DBPATH/installed/$ARG ]; then
            echo "$ARG is already installed" && exit 1
        fi
        PKGMATCH="$(fn_get_pkgmatch $ARG)"
        if [ -f $CACHEDIR/$(basename $PKGMATCH) ]; then
            ARG="$(basename $PKGMATCH)"
            cd $CACHEDIR && fn_pkg_install_local && cd $OLDPWD
        else
            fn_pkg_download
            if [ -f $CACHEDIR/"$(basename $PKGMATCH)" ]; then
                ARG="$(basename $PKGMATCH)"
                cd $CACHEDIR && fn_pkg_install_local && cd $OLDPWD
            fi
        fi
    done  
    
}

fn_pkg_remove() {
    for i in $ARGR; do
        if [ -d $DBPATH/installed/$i ]; then
            . $DBPATH/installed/$i/pkginfo
            echo -n "Removing $i"
            cat $DBPATH/installed/$i/files | while read file; do 
                if [ -f "$file" ]; then rm "$file"; fi
            done
            rm -r $DBPATH/installed/$i
            echo
        else
            echo "$ARG is not installed"
        fi
    done
}

fn_pkg_clean_cache() {
    rm $CACHEDIR/* 2>/dev/null
}

fn_pkg_show_help() {
    echo "Usage: $(basename $0) <command> [arguments]

where <command> is one of:
    up: Update repository database
    sr: Search for packages
    dl: Download package(s)
    xp: Extract a single package (specify filename)
    xa: Extract all packages from the current directory
    it: Install package(s) (local or from a repository)
    rm: Uninstall package(s)
    cc: Delete cached packages
"
}

# Arguments
case "$1" in
    up) fn_repo_update ;;
    sr) ARG="$2"; fn_pkg_search ;;
    dl) shift; ARGD="$@"; fn_pkg_download_all ;;
    xp) ARG="$2"; fn_pkg_extract ;;
    xa) fn_pkg_extract_all ;;
    it) shift; ARGI="$@"; fn_pkg_install ;;
    rm) shift; ARGR="$@"; fn_pkg_remove ;;
    cc) fn_pkg_clean_cache ;;
    *) fn_pkg_show_help ;;
esac
